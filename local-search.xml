<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>638-大礼包</title>
    <link href="/2021/10/24/638-%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    <url>/2021/10/24/638-%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p><p>给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。</p><p>还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。</p><p>返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。<br>链接：<a href="https://leetcode-cn.com/problems/shopping-offers">https://leetcode-cn.com/problems/shopping-offers</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>法一：记忆化搜索</p><p>m种物品，需求n，购物清单最多有m^n种。把购物清单needs视作状态，考虑相互转移的方法。不是所有状态都有用（稀疏），用memo的方法。</p><p>首先过滤掉不优惠的大礼包，即大礼包的价格比原价购买还高的大礼包。</p><p>用dp[needs] 表示购物清单needs的最低价格，进行状态转移时，考虑最后一次购买，有两种情况：</p><ul><li><p>第一种是购买大礼包</p><ul><li>考虑所有礼包，购买物品数量不超过购物清单的大礼包<br>$$<br>dp[needs] = min{spcecialPrice_i + dp[needs - needs_i]}  i \in k<br>$$</li></ul></li><li><p>第二种原价购买</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">    <span class="hljs-type">Map</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt;, <span class="hljs-type">Integer</span>&gt; memo = new <span class="hljs-type">HashMap</span>&lt;&gt;();</span><br><span class="hljs-class"></span><br><span class="hljs-class">    public int shoppingOffers(<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">price</span>, <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt;&gt; <span class="hljs-title">special</span>, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">needs</span>) &#123;</span><br><span class="hljs-class">        <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt;&gt; fillterSpecial = new <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt;&gt;();</span><br><span class="hljs-class">        int n = price.size();</span><br><span class="hljs-class">        //预处理</span><br><span class="hljs-class">        for(<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">spe</span> : <span class="hljs-title">special</span>)&#123;</span><br><span class="hljs-class">            int totalP = 0;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0; <span class="hljs-title">i</span> &lt; <span class="hljs-title">n</span>; <span class="hljs-title">i</span>++ )&#123;</span><br><span class="hljs-class">                totalP += spe.get(<span class="hljs-title">i</span>) * price.get(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            if(<span class="hljs-title">totalP</span> &gt; <span class="hljs-title">spe</span>.<span class="hljs-title">get</span>(<span class="hljs-title">n</span>))&#123;</span><br><span class="hljs-class">                fillterSpecial.add(<span class="hljs-title">spe</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        return dfs(<span class="hljs-title">price</span>, <span class="hljs-title">fillterSpecial</span>, <span class="hljs-title">needs</span>, <span class="hljs-title">n</span>);</span><br><span class="hljs-class"></span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    int dfs(<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">price</span>, <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt;&gt; <span class="hljs-title">fillterSpecial</span>, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">curNeeds</span>, <span class="hljs-title">int</span> <span class="hljs-title">n</span>)&#123;</span><br><span class="hljs-class">        if(!<span class="hljs-title">memo</span>.<span class="hljs-title">containsKey</span>(<span class="hljs-title">curNeeds</span>))&#123;</span><br><span class="hljs-class">            int minPrce = 0;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0; <span class="hljs-title">i</span> &lt; <span class="hljs-title">n</span>; <span class="hljs-title">i</span>++)&#123;</span><br><span class="hljs-class">                minPrce += price.get(<span class="hljs-title">i</span>) * curNeeds.get(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            for(<span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-title">spe</span> : <span class="hljs-title">fillterSpecial</span>)&#123;</span><br><span class="hljs-class">                <span class="hljs-type">List</span>&lt;<span class="hljs-type">Integer</span>&gt; nxtNeeds = new <span class="hljs-type">ArrayList</span>&lt;&gt;();</span><br><span class="hljs-class">                for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0; <span class="hljs-title">i</span> &lt; <span class="hljs-title">n</span>; <span class="hljs-title">i</span>++)&#123;</span><br><span class="hljs-class">                    if(<span class="hljs-title">spe</span>.<span class="hljs-title">get</span>(<span class="hljs-title">i</span>) &lt;= curNeeds.get(<span class="hljs-title">i</span>))&#123;</span><br><span class="hljs-class">                        nxtNeeds.add(<span class="hljs-title">curNeeds</span>.<span class="hljs-title">get</span>(<span class="hljs-title">i</span>) - spe.get(<span class="hljs-title">i</span>));</span><br><span class="hljs-class">                    &#125;</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">                if(<span class="hljs-title">nxtNeeds</span>.<span class="hljs-title">size</span>()== n)&#123;</span><br><span class="hljs-class">                    minPrce = <span class="hljs-type">Math</span>.min(<span class="hljs-title">minPrce</span>, <span class="hljs-title">spe</span>.<span class="hljs-title">get</span>(<span class="hljs-title">n</span>) + dfs(<span class="hljs-title">price</span>, <span class="hljs-title">fillterSpecial</span>, <span class="hljs-title">nxtNeeds</span>, <span class="hljs-title">n</span>));</span><br><span class="hljs-class">                   </span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            memo.put(<span class="hljs-title">curNeeds</span>,<span class="hljs-title">minPrce</span>);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return memo.get(<span class="hljs-title">curNeeds</span>);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class"></span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>229-求众树II</title>
    <link href="/2021/10/22/229-%E6%B1%82%E4%BC%97%E6%A0%91II/"/>
    <url>/2021/10/22/229-%E6%B1%82%E4%BC%97%E6%A0%91II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>法一：用hash表统计，扫描一遍，时间复杂度O(n)。</p><p>法二：摩尔投票</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    public <span class="hljs-built_in">List</span>&lt;Integer&gt; majorityElement(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <span class="hljs-built_in">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = <span class="hljs-built_in">num</span>;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = <span class="hljs-built_in">num</span>;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">num</span> == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-built_in">List</span>&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            ans.add(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            ans.add(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>230-二叉搜索树中第k小的元素</title>
    <link href="/2021/10/17/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2021/10/17/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p> 给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。 </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>中序遍历。</p><p>迭代过程中找到第k个。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;TreeNode&gt;();<br><br>        <span class="hljs-keyword">while</span>(root!=null || !stack.<span class="hljs-built_in">isEmpty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(root!=null)&#123;<br>                stack.<span class="hljs-built_in">push</span>(root);<br>                root = root.left;<br>            &#125;<br><br>            root = stack.<span class="hljs-built_in">pop</span>();<br>            k--;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>069-山峰数组的顶部</title>
    <link href="/2021/10/16/069-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8/"/>
    <url>/2021/10/16/069-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8/</url>
    
    <content type="html"><![CDATA[<p>符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：</p><p>arr.length &gt;= 3<br>存在 i（0 &lt; i &lt; arr.length - 1）使得：<br>arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]<br>arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]<br>给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/B1IidL">https://leetcode-cn.com/problems/B1IidL</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意就是找到最大值，返回index。数组有山峰的特性。分治法</p><p>分解：按mid分</p><p>解决：因为数组特性，arr[mid] 如果比左右都大，就返回mid，否则，最大值就在左右比arr[mid]大的一边中。</p><p>合并：不需要合并</p><p>递归出口：只有一两个数，判断返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> peakIndexInMountainArray(<span class="hljs-built_in">int</span>[] arr) &#123;<br>        return partition(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>&gt;=<span class="hljs-built_in">right</span>) return <span class="hljs-built_in">left</span>;<br>        <span class="hljs-built_in">if</span>((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) == <span class="hljs-number">1</span>) return arr[<span class="hljs-built_in">left</span>]&gt;arr[<span class="hljs-built_in">right</span>]? le<span class="hljs-symbol">ft:ri</span>ght;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">mid</span>] &lt; arr[<span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>])&#123;<br>            return partition(arr, <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);<br>        &#125;else <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">mid</span>] &lt; arr[<span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>])&#123;<br>            return partition(arr,<span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span> -<span class="hljs-number">1</span>);<br>        &#125;else&#123;<br>            return <span class="hljs-built_in">mid</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>240-搜素二维矩阵II</title>
    <link href="/2021/10/09/240-%E6%90%9C%E7%B4%A0%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <url>/2021/10/09/240-%E6%90%9C%E7%B4%A0%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>166-分数to小数</title>
    <link href="/2021/10/03/166-%E5%88%86%E6%95%B0to%E5%B0%8F%E6%95%B0/"/>
    <url>/2021/10/03/166-%E5%88%86%E6%95%B0to%E5%B0%8F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 任意一个 。</p><p>对于所有给定的输入，保证 答案字符串的长度小于 104 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal">https://leetcode-cn.com/problems/fraction-to-recurring-decimal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用哈希表记录所有被除数 下标，如果出现重复的被除数，则证明开始循环出现，把左括号放到小标位置， 右括号放最后。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs processing">class Solution &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> fractionToDecimal(<span class="hljs-built_in">int</span> numerator, <span class="hljs-built_in">int</span> denominator) &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">long</span> a = numerator, b = denominator;<br>       <br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; b &lt; <span class="hljs-number">0</span> || a &lt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span>) sb.<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        a = Math.<span class="hljs-built_in">abs</span>(a);<br>        b = Math.<span class="hljs-built_in">abs</span>(b);<br>        sb.<span class="hljs-built_in">append</span>(a/b);<br>        <span class="hljs-keyword">if</span>(a%b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sb.toString();<br>        sb.<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br><br>        Map&lt;Long, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>((a = a % b *<span class="hljs-number">10</span>)!= <span class="hljs-number">0</span>)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.containsKey(a))&#123;<br>                <span class="hljs-built_in">map</span>.put(a, sb.length());<br>                sb.<span class="hljs-built_in">append</span>(a/b);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sb.toString();<br>        <span class="hljs-keyword">return</span> sb.insert(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(a).intValue(), <span class="hljs-string">&#x27;(&#x27;</span>).<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;)&#x27;</span>).toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="/2021/09/30/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2021/09/30/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: []</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,2,3,1]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>另cnt[i]表示i位置nums[i]之前比他大的数字个数，那么逆序对数就是cnt[i]累加。</p><p>可以在归并排序中统计。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;<br>    public <span class="hljs-built_in">int</span> reverse<span class="hljs-constructor">Pairs(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span>]</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span>]</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        &#125;<br>        merge<span class="hljs-constructor">Sort(0,<span class="hljs-params">nums</span>.<span class="hljs-params">length</span>-1, <span class="hljs-params">arr</span>, <span class="hljs-params">temp</span>)</span>;<br>        return cnt;<br>    &#125;<br>    <br>    void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">temp</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) return; <span class="hljs-comment">//&gt; 考虑数组为空的情况， 也可以在之前判断</span><br>        <span class="hljs-built_in">int</span> mid = (r-l)/<span class="hljs-number">2</span> + l;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">l</span>, <span class="hljs-params">mid</span>, <span class="hljs-params">arr</span>, <span class="hljs-params">temp</span>)</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">mid</span>+1, <span class="hljs-params">r</span>, <span class="hljs-params">arr</span>, <span class="hljs-params">temp</span>)</span>;<br>        <span class="hljs-comment">//merge</span><br> <br>        <span class="hljs-built_in">int</span> i = l, j = mid+<span class="hljs-number">1</span>, k = l;<br>        <span class="hljs-keyword">while</span>( i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j&lt;=r)&#123; <br>            <span class="hljs-keyword">if</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)&#123; <span class="hljs-comment">// = 考虑数组中值相同的数，不构成逆序对</span><br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cnt = cnt + mid - i +<span class="hljs-number">1</span>;<br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(i&lt;=mid) temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=r) temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> q = l; q &lt;= r; q++) &#123;<br>            arr<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span> = temp<span class="hljs-literal">[<span class="hljs-identifier">q</span>]</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98-验证二叉搜素树</title>
    <link href="/2021/09/29/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91/"/>
    <url>/2021/09/29/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p> 给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。 </p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public boolean is<span class="hljs-constructor">ValidBST(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>        long min = Long.MIN_VALUE, max = Long.MAX_VALUE;<br>        return is<span class="hljs-constructor">BST(<span class="hljs-params">root</span>, <span class="hljs-params">min</span>, <span class="hljs-params">max</span>)</span>;<br><br>    &#125;<br><br>    public boolean is<span class="hljs-constructor">BST(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">long</span> <span class="hljs-params">min</span>, <span class="hljs-params">long</span> <span class="hljs-params">max</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>( root.<span class="hljs-keyword">val</span> &gt;= max<span class="hljs-operator"> || </span>root.<span class="hljs-keyword">val</span> &lt;= min ) return <span class="hljs-literal">false</span>;<br>        return is<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">min</span>, <span class="hljs-params">root</span>.<span class="hljs-params">val</span>)</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">root</span>.<span class="hljs-params">val</span>, <span class="hljs-params">max</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中序遍历为升序"><a href="#中序遍历为升序" class="headerlink" title="中序遍历为升序"></a>中序遍历为升序</h2>]]></content>
    
    
    <categories>
      
      <category>刷算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>437-路径总和</title>
    <link href="/2021/09/28/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2021/09/28/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先一个dfs遍历每个节点，另一个dfs找满足条件的路径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">/**<br> * <span class="hljs-type">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public <span class="hljs-keyword">class</span> <span class="hljs-type">TreeNode</span> &#123;<br> *     <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br> *     <span class="hljs-type">TreeNode</span> left;<br> *     <span class="hljs-type">TreeNode</span> right;<br> *     <span class="hljs-type">TreeNode</span><span class="hljs-literal">()</span> &#123;&#125;<br> *     <span class="hljs-type">TreeNode</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br> *     <span class="hljs-type">TreeNode</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">TreeNode</span> left, <span class="hljs-type">TreeNode</span> right) &#123;<br> *         this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;<br>    <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>, t;<br>    public <span class="hljs-built_in">int</span> pathSum(<span class="hljs-type">TreeNode</span> root, <span class="hljs-built_in">int</span> targetSum) &#123;<br>        t = targetSum;<br>        dfs1(root);<br>        return ans;<br>    &#125;<br><br>    void dfs1(<span class="hljs-type">TreeNode</span> root)&#123;<br>        <span class="hljs-keyword">if</span>(root == null) return;<br>        dfs2(root, root.<span class="hljs-keyword">val</span>);<br>        dfs1(root.left);<br>        dfs1(root.right);<br>    &#125;<br><br>    void dfs2(<span class="hljs-type">TreeNode</span> root, <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> ==t ) ans++;<br>        <span class="hljs-keyword">if</span>(root.left !=null) dfs2(root.left, <span class="hljs-keyword">val</span>+root.left.<span class="hljs-keyword">val</span>);<br>        <span class="hljs-keyword">if</span>(root.right !=null) dfs2(root.right, <span class="hljs-keyword">val</span>+root.right.<span class="hljs-keyword">val</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2>]]></content>
    
    
    
    <tags>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>91-解码方法</title>
    <link href="/2021/09/27/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <url>/2021/09/27/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dp[i] 表示 i位置解码方案数</p><p>i位置字符可解码，则dp[i] += dp[i-1]</p><p>【i-1 i】可解码，则dp[i] += dp[i-2]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> numDecodings(String s) &#123;<br>        <br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[s.length()+<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> t = s.charAt(i<span class="hljs-number">-1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> &amp;&amp; t &lt;= <span class="hljs-number">2</span>)&#123;<br>                        dp[i+<span class="hljs-number">2</span>] += dp[i];<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i+<span class="hljs-number">2</span>] += dp[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(i<span class="hljs-number">-1</span>) != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        <span class="hljs-type">int</span> t = s.charAt(i<span class="hljs-number">-1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        <span class="hljs-type">int</span> g = s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        <span class="hljs-type">int</span> d = <span class="hljs-number">10</span>*t+g;<br>                        <span class="hljs-keyword">if</span>( d&lt;=<span class="hljs-number">26</span> &amp;&amp; d&gt;<span class="hljs-number">0</span>)&#123;<br>                            dp[i+<span class="hljs-number">2</span>] += dp[i];<br>                        &#125;<br>                    &#125;<br>                    <br>                &#125;<br>                <br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优雅的代码"><a href="#优雅的代码" class="headerlink" title="优雅的代码"></a>优雅的代码</h2><p>由于题目存在前导零，而前导零属于无效 item。可以进行特判，但习惯往字符串头部追加空格作为哨兵，追加空格既可以避免讨论前导零，也能使下标从 1 开始，简化 f[i-1] 等负数下标的判断。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        <span class="hljs-keyword">char</span>[] cs = s.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <br>            <span class="hljs-comment">// a : 代表「当前位置」单独形成 item</span><br>            <span class="hljs-comment">// b : 代表「当前位置」与「前一位置」共同形成 item</span><br>            <span class="hljs-keyword">int</span> a = cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>, b = (cs[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">// 如果 a 属于有效值，那么 f[i] 可以由 f[i - 1] 转移过来</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">9</span>) f[i] = f[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果 b 属于有效值，那么 f[i] 可以由 f[i - 2] 或者 f[i - 1] &amp; f[i - 2] 转移过来</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= b &amp;&amp; b &lt;= <span class="hljs-number">26</span>) f[i] += f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/decode-ways/solution/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd/</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加哨兵。</p><p>其实不用特意考虑0</p>]]></content>
    
    
    <categories>
      
      <category>刷算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>583-两个字符串的删除操作</title>
    <link href="/2021/09/26/583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/09/26/583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p> 给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;sea&quot;</span>, <span class="hljs-string">&quot;eat&quot;</span><br>输出: <span class="hljs-number">2</span><br>解释: 第一步将<span class="hljs-string">&quot;sea&quot;</span>变为<span class="hljs-string">&quot;ea&quot;</span>，第二步将<span class="hljs-string">&quot;eat&quot;</span>变为<span class="hljs-string">&quot;ea&quot;</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>转化为求最长公共子序列</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Distance(String <span class="hljs-params">word1</span>, String <span class="hljs-params">word2</span>)</span> &#123;<br>        <span class="hljs-comment">//找最长公共子序列</span><br>        <span class="hljs-built_in">int</span> m = word1.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> n = word2.length<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">//dp[i][j] 表示word1[0...i-1] 与 word2[0...j-1]的最大公共子序列长度</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">m</span>+<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>+<span class="hljs-number">1</span>]</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(word1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>-1)</span><span class="hljs-operator"> == </span>word2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>-1)</span>)&#123;<br>                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        return m + n - dp<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span>*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>430-扁平化多级双向链表</title>
    <link href="/2021/09/25/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/25/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：<br><br>输入的多级列表如下图所示：<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/gmy99/pic-go/raw/master/img/202109252108936.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dfs</p><p>迭代</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/*<br>// Definition for a Node.<br>class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    public</span> int val;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">prev</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">child</span>;<br>&#125;;<br>*/<br><br>class Solution &#123;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">flatten</span>(<span class="hljs-keyword">Node</span> <span class="hljs-title">head</span>) &#123;<br>        // 有child，child.<span class="hljs-attr">prev=</span>parent. 记parent<br>        // 没有child,next<br>        //     next 为空，回到parant<br><br>        <span class="hljs-keyword">Node</span> <span class="hljs-title">cur</span> = head;<br>        int i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">Node</span><span class="hljs-title">[] parent</span> = new <span class="hljs-keyword">Node</span><span class="hljs-title">[1000</span>];<br>        while(cur != null)&#123;<br>            if(cur.child != null)&#123;<br>                parent[i++] = cur;<br>                cur = cur.child;<br>                cur.prev = parent[i-<span class="hljs-number">1</span>];<br>            &#125;else&#123;<br>                <span class="hljs-keyword">Node</span> <span class="hljs-title">pre</span> = cur;<br>                cur = cur.next;<br>                while(cur == null &amp;&amp; i&gt;<span class="hljs-number">0</span>)&#123; //到底且有parent<br>                    cur = parent[--i].next;//回溯<br>                    parent[i].next = parent[i].child;<br>                    parent[i].child = null;<br>                    if(cur !=null)&#123;<br>                         pre.next = cur;<br>                        cur.prev = pre;<br>                    &#125;<br>                   <br>                &#125;<br>            &#125;<br>        &#125;<br>        return head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><p> 为防止空节点等边界问题，起始时建立一个哨兵节点 dummy 指向 head</p><p>有child的时候，把child的last接到tmp上，不用栈存parent</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xquery">class Solution &#123;<br>    public Node flatten(Node<span class="hljs-built_in"> head</span>) &#123;<br>        Node dummy = new Node(<span class="hljs-number">0</span>);<br>        dummy.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>        <span class="hljs-keyword">for</span> (;<span class="hljs-built_in"> head</span> != null;<span class="hljs-built_in"> head</span> =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span>.child != null) &#123;<br>                Node tmp =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>                Node child =<span class="hljs-built_in"> head</span>.child;<br>               <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = child;<br>                child.prev =<span class="hljs-built_in"> head</span>;<br>               <span class="hljs-built_in"> head</span>.child = null;<br>                Node<span class="hljs-built_in"> last</span> =<span class="hljs-built_in"> head</span>;<br>                while <span class="hljs-built_in">(last</span>.<span class="hljs-keyword">next</span> != null)<span class="hljs-built_in"> last</span> =<span class="hljs-built_in"> last</span>.<span class="hljs-keyword">next</span>;<br>               <span class="hljs-built_in"> last</span>.<span class="hljs-keyword">next</span> = tmp;<br>                <span class="hljs-keyword">if</span> (tmp != null) tmp.prev =<span class="hljs-built_in"> last</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-<span class="hljs-number">9</span>wfz/）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>725-分隔链表</title>
    <link href="/2021/09/25/725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/25/725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p><p>这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p><p>返回一个由上述 k 部分组成的数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-linked-list-in-parts">https://leetcode-cn.com/problems/split-linked-list-in-parts</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3]</span>, k = <span class="hljs-number">5</span><br>输出：<span class="hljs-selector-attr">[[1]</span>,<span class="hljs-selector-attr">[2]</span>,<span class="hljs-selector-attr">[3]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>]<br>解释：<br>第一个元素 output<span class="hljs-selector-attr">[0]</span> 为 output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">1</span> ，output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.next</span> = null 。<br>最后一个元素 output<span class="hljs-selector-attr">[4]</span> 为 null ，但它作为 ListNode 的字符串表示是 <span class="hljs-selector-attr">[]</span> 。<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是尽可能均匀分成k分，所以链表数组长度为k，每个链表元素中节点数最少为 head.length/k。</p><p>余下的节点head.length%k应该要逐个分个前面的元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs q">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     ListNode <span class="hljs-built_in">next</span>;<br> *     ListNode() &#123;&#125;<br> *     ListNode(<span class="hljs-type">int</span> val) &#123; this.val = val; &#125;<br> *     ListNode(<span class="hljs-type">int</span> val, ListNode <span class="hljs-built_in">next</span>) &#123; this.val = val; this.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode[] splitListToParts(ListNode head, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> len = getLen(head);<br>        <span class="hljs-type">int</span> a = len / k;<br>        <span class="hljs-type">int</span> b = len % k;<br>        ListNode output[] = new ListNode[k];<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        ListNode p = head;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-built_in">null</span> &amp;&amp; i&lt;k)&#123;<br>            output[i] = p;<br>            i++;<br>            if(a!=<span class="hljs-number">0</span>)&#123;<br>                for(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a<span class="hljs-number">-1</span>; j++)&#123;<br>                    p = p.<span class="hljs-built_in">next</span>;<br>                &#125;<br>                if(b!=<span class="hljs-number">0</span>)&#123;<br>                    p = p.<span class="hljs-built_in">next</span>;<br>                    b--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//断链</span><br>            if(p != <span class="hljs-built_in">null</span>)&#123;<br>                 ListNode t = p.<span class="hljs-built_in">next</span>;<br>                p.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">null</span>;<br>                p = t;<br>            &#125;<br>           <br>        &#125;<br>        <span class="hljs-comment">// //空元素补null ，初始化为null，不用补</span><br>        <span class="hljs-comment">// while(i&lt;k)&#123;</span><br>        <span class="hljs-comment">//     output[i] = null;</span><br>        <span class="hljs-comment">//     i++;</span><br>        <span class="hljs-comment">// &#125;</span><br>        return output;<br>    &#125;<br><br>    <span class="hljs-type">int</span> getLen(ListNode head)&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-built_in">null</span>)&#123;<br>            len++;<br>            head = head.<span class="hljs-built_in">next</span>;<br>        &#125;<br>        return len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>673-最长递增子序列的个数</title>
    <link href="/2021/09/25/673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/09/25/673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> 给定一个未排序的整数数组，找到最长递增子序列的个数。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在300找LIS的基础上，加一个数组记录i位置结尾的LIS的个数，最后把序列最长的数量累加。</p><h2 id="代码-O-N-2"><a href="#代码-O-N-2" class="headerlink" title="代码 O(N^2)"></a>代码 O(N^2)</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>    public int findNumberOfLIS(int<span class="hljs-comment">[]</span> nums) &#123;<br>        int dp<span class="hljs-comment">[]</span> = new int<span class="hljs-comment">[nums.length]</span>;<br>        int combination<span class="hljs-comment">[]</span> = new int<span class="hljs-comment">[nums.length]</span>;<br>        int max = 1;<br>        for(int i = 0; i &lt; nums.length; i++) &#123;<br>        dp<span class="hljs-comment">[i]</span> = 1;<br>        combination<span class="hljs-comment">[i]</span> = 1;<br>        &#125;<br>        for(int i = 1; i &lt; nums.length; i++)&#123;<br>            for(int j = 0; j &lt; i; j++)&#123;<br>                if(nums<span class="hljs-comment">[j]</span> &lt; nums<span class="hljs-comment">[i]</span>)&#123;<br>                if(dp<span class="hljs-comment">[i]</span> &lt; dp<span class="hljs-comment">[j]</span> + 1)&#123;<br>                dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[j]</span> + 1;<br>                // 长度dp加1了，相当于任然是当前LIS，组合数不变<br>                combination<span class="hljs-comment">[i]</span> = combination<span class="hljs-comment">[j]</span>;<br>                &#125;else if(dp<span class="hljs-comment">[i]</span> == dp<span class="hljs-comment">[j]</span> + 1)&#123;<br>                // 长度不变，找到了新的组合。<br>                combination<span class="hljs-comment">[i]</span> += combination<span class="hljs-comment">[j]</span>;<br>                &#125;<br>                    dp<span class="hljs-comment">[i]</span> = (dp<span class="hljs-comment">[j]</span> + 1) &gt; dp<span class="hljs-comment">[i]</span> ? dp<span class="hljs-comment">[j]</span> + 1 : dp<span class="hljs-comment">[i]</span>;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        int res = 0;<br>        for(int i = 0; i&lt; nums.length; ++i)&#123;<br>            if(dp<span class="hljs-comment">[i]</span> == max)&#123;<br>                res+=combination<span class="hljs-comment">[i]</span>;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300.最长递增子序列</title>
    <link href="/2021/09/24/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/09/24/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="dp-定义"><a href="#dp-定义" class="headerlink" title="dp[]定义"></a>dp[]定义</h2><p>dp[i] 为 已 num[i]终止的最长递增子序列长度</p><h2 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h2><p>位置i的LIS长度等于0-i-1位置LIS长度+1的最大值</p><p>所以，当num[i] 比 num[j]大时 ，dp[i] = max(dp[j]+1,dp[i]) 。 0&lt;j&lt;i</p><h2 id="dp-i-初始化"><a href="#dp-i-初始化" class="headerlink" title="dp[i]初始化"></a>dp[i]初始化</h2><p>至少为1（本身）</p><h2 id="代码-O-N-2"><a href="#代码-O-N-2" class="headerlink" title="代码 O(N^2)"></a>代码 O(N^2)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;<br>                    dp[i] = (dp[j] + <span class="hljs-number">1</span>) &gt; dp[i] ? dp[j] + <span class="hljs-number">1</span> : dp[i];<br>                    res = dp[i] &gt; res ? dp[i] : res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p> 相当于维护一个结果数组，如果当前元素比结果数组的值都大的的话，就追加在结果数组后面（相当于递增序列长度加了1）；否则的话用当前元素覆盖掉第一个比它大的元素（这样做的话后续递增序列才有可能更长，即使并没有更长，这个覆盖操作也并没有副作用哈，当然这个覆盖操作可能会让最终的结果数组值并不是最终的递增序列值，这无所谓） </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> lengthOfLIS(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span>[] res = new <span class="hljs-built_in">int</span>[nums.length];<br>        for(<span class="hljs-built_in">int</span> num <span class="hljs-symbol">:</span> nums) &#123;<br>            // 二分法查找, 也可以调用库函数如binary_search<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span>;<br>            while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>                <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>                <span class="hljs-built_in">if</span>(res[<span class="hljs-built_in">mid</span>] &lt; num)<br>                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>                else<br>                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>            &#125;<br>            res[<span class="hljs-built_in">left</span>] = num;<br>            <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span> == <span class="hljs-built_in">len</span>)<br>                <span class="hljs-built_in">len</span>++;<br>        &#125;<br>        return <span class="hljs-built_in">len</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2021/09/07/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/09/07/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># NodeJs安装</span><br><br><span class="hljs-meta"># 确认版本号</span><br>node -v<br>npm -v<br><br><span class="hljs-meta"># 安装Node.js淘宝镜像加速器（cnpm）</span><br>npm install -g cnpm --registry=https:<span class="hljs-comment">//registry.npm.taobao.org</span><br>cnpm -v<br></code></pre></td></tr></table></figure><hr><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cnpm <span class="hljs-keyword">install</span> -g hexo-cil<br>hexo -v<br></code></pre></td></tr></table></figure><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mkdir blog<br>cd blog<br><br>sudo hexo init <span class="hljs-meta">#初始化生成博客</span><br><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta"># 启动本地博客服务 4000端口</span><br><br>hexo <span class="hljs-keyword">new</span>  <span class="hljs-string">&quot;post名称&quot;</span>  <span class="hljs-meta"># 创建新文章</span><br><br>hexo clean  <span class="hljs-meta"># 清理</span><br><br>hexo g <span class="hljs-meta"># 生成</span><br></code></pre></td></tr></table></figure><h2 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#项目根目录下安装git 部署插件</span><br><br>cnpm <span class="hljs-keyword">install </span>--save hexo-deployer-git<br><br><br><br>配置文件_<span class="hljs-built_in">config</span>.yml设置<br><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codesheep.cn/">www.codesheep.cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/07/hello-world/"/>
    <url>/2021/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
