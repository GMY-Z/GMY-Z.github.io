<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>437-路径总和</title>
    <link href="/2021/09/28/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2021/09/28/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先一个dfs遍历每个节点，另一个dfs找满足条件的路径。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">/**<br> * <span class="hljs-type">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * public <span class="hljs-keyword">class</span> <span class="hljs-type">TreeNode</span> &#123;<br> *     <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br> *     <span class="hljs-type">TreeNode</span> left;<br> *     <span class="hljs-type">TreeNode</span> right;<br> *     <span class="hljs-type">TreeNode</span><span class="hljs-literal">()</span> &#123;&#125;<br> *     <span class="hljs-type">TreeNode</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>) &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br> *     <span class="hljs-type">TreeNode</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">TreeNode</span> left, <span class="hljs-type">TreeNode</span> right) &#123;<br> *         this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br> *         this.left = left;<br> *         this.right = right;<br> *     &#125;<br> * &#125;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;<br>    <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>, t;<br>    public <span class="hljs-built_in">int</span> pathSum(<span class="hljs-type">TreeNode</span> root, <span class="hljs-built_in">int</span> targetSum) &#123;<br>        t = targetSum;<br>        dfs1(root);<br>        return ans;<br>    &#125;<br><br>    void dfs1(<span class="hljs-type">TreeNode</span> root)&#123;<br>        <span class="hljs-keyword">if</span>(root == null) return;<br>        dfs2(root, root.<span class="hljs-keyword">val</span>);<br>        dfs1(root.left);<br>        dfs1(root.right);<br>    &#125;<br><br>    void dfs2(<span class="hljs-type">TreeNode</span> root, <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> ==t ) ans++;<br>        <span class="hljs-keyword">if</span>(root.left !=null) dfs2(root.left, <span class="hljs-keyword">val</span>+root.left.<span class="hljs-keyword">val</span>);<br>        <span class="hljs-keyword">if</span>(root.right !=null) dfs2(root.right, <span class="hljs-keyword">val</span>+root.right.<span class="hljs-keyword">val</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2>]]></content>
    
    
    
    <tags>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>91-解码方法</title>
    <link href="/2021/09/27/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <url>/2021/09/27/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射<br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dp[i] 表示 i位置解码方案数</p><p>i位置字符可解码，则dp[i] += dp[i-1]</p><p>【i-1 i】可解码，则dp[i] += dp[i-2]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> numDecodings(String s) &#123;<br>        <br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[s.length()+<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> t = s.charAt(i<span class="hljs-number">-1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span>( t &gt; <span class="hljs-number">0</span> &amp;&amp; t &lt;= <span class="hljs-number">2</span>)&#123;<br>                        dp[i+<span class="hljs-number">2</span>] += dp[i];<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i+<span class="hljs-number">2</span>] += dp[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(i<span class="hljs-number">-1</span>) != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        <span class="hljs-type">int</span> t = s.charAt(i<span class="hljs-number">-1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        <span class="hljs-type">int</span> g = s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        <span class="hljs-type">int</span> d = <span class="hljs-number">10</span>*t+g;<br>                        <span class="hljs-keyword">if</span>( d&lt;=<span class="hljs-number">26</span> &amp;&amp; d&gt;<span class="hljs-number">0</span>)&#123;<br>                            dp[i+<span class="hljs-number">2</span>] += dp[i];<br>                        &#125;<br>                    &#125;<br>                    <br>                &#125;<br>                <br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优雅的代码"><a href="#优雅的代码" class="headerlink" title="优雅的代码"></a>优雅的代码</h2><p>由于题目存在前导零，而前导零属于无效 item。可以进行特判，但习惯往字符串头部追加空格作为哨兵，追加空格既可以避免讨论前导零，也能使下标从 1 开始，简化 f[i-1] 等负数下标的判断。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        <span class="hljs-keyword">char</span>[] cs = s.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <br>            <span class="hljs-comment">// a : 代表「当前位置」单独形成 item</span><br>            <span class="hljs-comment">// b : 代表「当前位置」与「前一位置」共同形成 item</span><br>            <span class="hljs-keyword">int</span> a = cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>, b = (cs[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-comment">// 如果 a 属于有效值，那么 f[i] 可以由 f[i - 1] 转移过来</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= a &amp;&amp; a &lt;= <span class="hljs-number">9</span>) f[i] = f[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 如果 b 属于有效值，那么 f[i] 可以由 f[i - 2] 或者 f[i - 1] &amp; f[i - 2] 转移过来</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= b &amp;&amp; b &lt;= <span class="hljs-number">26</span>) f[i] += f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/decode-ways/solution/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd/</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>加哨兵。</p><p>其实不用特意考虑0</p>]]></content>
    
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>583-两个字符串的删除操作</title>
    <link href="/2021/09/26/583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/09/26/583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p> 给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-string">&quot;sea&quot;</span>, <span class="hljs-string">&quot;eat&quot;</span><br>输出: <span class="hljs-number">2</span><br>解释: 第一步将<span class="hljs-string">&quot;sea&quot;</span>变为<span class="hljs-string">&quot;ea&quot;</span>，第二步将<span class="hljs-string">&quot;eat&quot;</span>变为<span class="hljs-string">&quot;ea&quot;</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>转化为求最长公共子序列</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Distance(String <span class="hljs-params">word1</span>, String <span class="hljs-params">word2</span>)</span> &#123;<br>        <span class="hljs-comment">//找最长公共子序列</span><br>        <span class="hljs-built_in">int</span> m = word1.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> n = word2.length<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">//dp[i][j] 表示word1[0...i-1] 与 word2[0...j-1]的最大公共子序列长度</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">m</span>+<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>+<span class="hljs-number">1</span>]</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(word1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>-1)</span><span class="hljs-operator"> == </span>word2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>-1)</span>)&#123;<br>                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        return m + n - dp<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span>*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>430-扁平化多级双向链表</title>
    <link href="/2021/09/25/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/25/430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：<br><br>输入的多级列表如下图所示：<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/gmy99/pic-go/raw/master/img/202109252108936.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dfs</p><p>迭代</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/*<br>// Definition for a Node.<br>class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    public</span> int val;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">prev</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">child</span>;<br>&#125;;<br>*/<br><br>class Solution &#123;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">flatten</span>(<span class="hljs-keyword">Node</span> <span class="hljs-title">head</span>) &#123;<br>        // 有child，child.<span class="hljs-attr">prev=</span>parent. 记parent<br>        // 没有child,next<br>        //     next 为空，回到parant<br><br>        <span class="hljs-keyword">Node</span> <span class="hljs-title">cur</span> = head;<br>        int i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">Node</span><span class="hljs-title">[] parent</span> = new <span class="hljs-keyword">Node</span><span class="hljs-title">[1000</span>];<br>        while(cur != null)&#123;<br>            if(cur.child != null)&#123;<br>                parent[i++] = cur;<br>                cur = cur.child;<br>                cur.prev = parent[i-<span class="hljs-number">1</span>];<br>            &#125;else&#123;<br>                <span class="hljs-keyword">Node</span> <span class="hljs-title">pre</span> = cur;<br>                cur = cur.next;<br>                while(cur == null &amp;&amp; i&gt;<span class="hljs-number">0</span>)&#123; //到底且有parent<br>                    cur = parent[--i].next;//回溯<br>                    parent[i].next = parent[i].child;<br>                    parent[i].child = null;<br>                    if(cur !=null)&#123;<br>                         pre.next = cur;<br>                        cur.prev = pre;<br>                    &#125;<br>                   <br>                &#125;<br>            &#125;<br>        &#125;<br>        return head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><p> 为防止空节点等边界问题，起始时建立一个哨兵节点 dummy 指向 head</p><p>有child的时候，把child的last接到tmp上，不用栈存parent</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xquery">class Solution &#123;<br>    public Node flatten(Node<span class="hljs-built_in"> head</span>) &#123;<br>        Node dummy = new Node(<span class="hljs-number">0</span>);<br>        dummy.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>        <span class="hljs-keyword">for</span> (;<span class="hljs-built_in"> head</span> != null;<span class="hljs-built_in"> head</span> =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span>.child != null) &#123;<br>                Node tmp =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>;<br>                Node child =<span class="hljs-built_in"> head</span>.child;<br>               <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = child;<br>                child.prev =<span class="hljs-built_in"> head</span>;<br>               <span class="hljs-built_in"> head</span>.child = null;<br>                Node<span class="hljs-built_in"> last</span> =<span class="hljs-built_in"> head</span>;<br>                while <span class="hljs-built_in">(last</span>.<span class="hljs-keyword">next</span> != null)<span class="hljs-built_in"> last</span> =<span class="hljs-built_in"> last</span>.<span class="hljs-keyword">next</span>;<br>               <span class="hljs-built_in"> last</span>.<span class="hljs-keyword">next</span> = tmp;<br>                <span class="hljs-keyword">if</span> (tmp != null) tmp.prev =<span class="hljs-built_in"> last</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-<span class="hljs-number">9</span>wfz/）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>725-分隔链表</title>
    <link href="/2021/09/25/725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/25/725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p><p>这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p><p>返回一个由上述 k 部分组成的数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-linked-list-in-parts">https://leetcode-cn.com/problems/split-linked-list-in-parts</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3]</span>, k = <span class="hljs-number">5</span><br>输出：<span class="hljs-selector-attr">[[1]</span>,<span class="hljs-selector-attr">[2]</span>,<span class="hljs-selector-attr">[3]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>]<br>解释：<br>第一个元素 output<span class="hljs-selector-attr">[0]</span> 为 output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">1</span> ，output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.next</span> = null 。<br>最后一个元素 output<span class="hljs-selector-attr">[4]</span> 为 null ，但它作为 ListNode 的字符串表示是 <span class="hljs-selector-attr">[]</span> 。<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是尽可能均匀分成k分，所以链表数组长度为k，每个链表元素中节点数最少为 head.length/k。</p><p>余下的节点head.length%k应该要逐个分个前面的元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs q">/**<br> * Definition for singly-linked list.<br> * public class ListNode &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     ListNode <span class="hljs-built_in">next</span>;<br> *     ListNode() &#123;&#125;<br> *     ListNode(<span class="hljs-type">int</span> val) &#123; this.val = val; &#125;<br> *     ListNode(<span class="hljs-type">int</span> val, ListNode <span class="hljs-built_in">next</span>) &#123; this.val = val; this.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>; &#125;<br> * &#125;<br> */<br>class Solution &#123;<br>    public ListNode[] splitListToParts(ListNode head, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> len = getLen(head);<br>        <span class="hljs-type">int</span> a = len / k;<br>        <span class="hljs-type">int</span> b = len % k;<br>        ListNode output[] = new ListNode[k];<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        ListNode p = head;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-built_in">null</span> &amp;&amp; i&lt;k)&#123;<br>            output[i] = p;<br>            i++;<br>            if(a!=<span class="hljs-number">0</span>)&#123;<br>                for(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a<span class="hljs-number">-1</span>; j++)&#123;<br>                    p = p.<span class="hljs-built_in">next</span>;<br>                &#125;<br>                if(b!=<span class="hljs-number">0</span>)&#123;<br>                    p = p.<span class="hljs-built_in">next</span>;<br>                    b--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//断链</span><br>            if(p != <span class="hljs-built_in">null</span>)&#123;<br>                 ListNode t = p.<span class="hljs-built_in">next</span>;<br>                p.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">null</span>;<br>                p = t;<br>            &#125;<br>           <br>        &#125;<br>        <span class="hljs-comment">// //空元素补null ，初始化为null，不用补</span><br>        <span class="hljs-comment">// while(i&lt;k)&#123;</span><br>        <span class="hljs-comment">//     output[i] = null;</span><br>        <span class="hljs-comment">//     i++;</span><br>        <span class="hljs-comment">// &#125;</span><br>        return output;<br>    &#125;<br><br>    <span class="hljs-type">int</span> getLen(ListNode head)&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-built_in">null</span>)&#123;<br>            len++;<br>            head = head.<span class="hljs-built_in">next</span>;<br>        &#125;<br>        return len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>673-最长递增子序列的个数</title>
    <link href="/2021/09/25/673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/09/25/673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> 给定一个未排序的整数数组，找到最长递增子序列的个数。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在300找LIS的基础上，加一个数组记录i位置结尾的LIS的个数，最后把序列最长的数量累加。</p><h2 id="代码-O-N-2"><a href="#代码-O-N-2" class="headerlink" title="代码 O(N^2)"></a>代码 O(N^2)</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>    public int findNumberOfLIS(int<span class="hljs-comment">[]</span> nums) &#123;<br>        int dp<span class="hljs-comment">[]</span> = new int<span class="hljs-comment">[nums.length]</span>;<br>        int combination<span class="hljs-comment">[]</span> = new int<span class="hljs-comment">[nums.length]</span>;<br>        int max = 1;<br>        for(int i = 0; i &lt; nums.length; i++) &#123;<br>        dp<span class="hljs-comment">[i]</span> = 1;<br>        combination<span class="hljs-comment">[i]</span> = 1;<br>        &#125;<br>        for(int i = 1; i &lt; nums.length; i++)&#123;<br>            for(int j = 0; j &lt; i; j++)&#123;<br>                if(nums<span class="hljs-comment">[j]</span> &lt; nums<span class="hljs-comment">[i]</span>)&#123;<br>                if(dp<span class="hljs-comment">[i]</span> &lt; dp<span class="hljs-comment">[j]</span> + 1)&#123;<br>                dp<span class="hljs-comment">[i]</span> = dp<span class="hljs-comment">[j]</span> + 1;<br>                // 长度dp加1了，相当于任然是当前LIS，组合数不变<br>                combination<span class="hljs-comment">[i]</span> = combination<span class="hljs-comment">[j]</span>;<br>                &#125;else if(dp<span class="hljs-comment">[i]</span> == dp<span class="hljs-comment">[j]</span> + 1)&#123;<br>                // 长度不变，找到了新的组合。<br>                combination<span class="hljs-comment">[i]</span> += combination<span class="hljs-comment">[j]</span>;<br>                &#125;<br>                    dp<span class="hljs-comment">[i]</span> = (dp<span class="hljs-comment">[j]</span> + 1) &gt; dp<span class="hljs-comment">[i]</span> ? dp<span class="hljs-comment">[j]</span> + 1 : dp<span class="hljs-comment">[i]</span>;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        int res = 0;<br>        for(int i = 0; i&lt; nums.length; ++i)&#123;<br>            if(dp<span class="hljs-comment">[i]</span> == max)&#123;<br>                res+=combination<span class="hljs-comment">[i]</span>;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300.最长递增子序列</title>
    <link href="/2021/09/24/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/09/24/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="dp-定义"><a href="#dp-定义" class="headerlink" title="dp[]定义"></a>dp[]定义</h2><p>dp[i] 为 已 num[i]终止的最长递增子序列长度</p><h2 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h2><p>位置i的LIS长度等于0-i-1位置LIS长度+1的最大值</p><p>所以，当num[i] 比 num[j]大时 ，dp[i] = max(dp[j]+1,dp[i]) 。 0&lt;j&lt;i</p><h2 id="dp-i-初始化"><a href="#dp-i-初始化" class="headerlink" title="dp[i]初始化"></a>dp[i]初始化</h2><p>至少为1（本身）</p><h2 id="代码-O-N-2"><a href="#代码-O-N-2" class="headerlink" title="代码 O(N^2)"></a>代码 O(N^2)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;<br>                    dp[i] = (dp[j] + <span class="hljs-number">1</span>) &gt; dp[i] ? dp[j] + <span class="hljs-number">1</span> : dp[i];<br>                    res = dp[i] &gt; res ? dp[i] : res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p> 相当于维护一个结果数组，如果当前元素比结果数组的值都大的的话，就追加在结果数组后面（相当于递增序列长度加了1）；否则的话用当前元素覆盖掉第一个比它大的元素（这样做的话后续递增序列才有可能更长，即使并没有更长，这个覆盖操作也并没有副作用哈，当然这个覆盖操作可能会让最终的结果数组值并不是最终的递增序列值，这无所谓） </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> lengthOfLIS(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        <br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span>[] res = new <span class="hljs-built_in">int</span>[nums.length];<br>        for(<span class="hljs-built_in">int</span> num <span class="hljs-symbol">:</span> nums) &#123;<br>            // 二分法查找, 也可以调用库函数如binary_search<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span>;<br>            while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>                <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>                <span class="hljs-built_in">if</span>(res[<span class="hljs-built_in">mid</span>] &lt; num)<br>                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>                else<br>                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>            &#125;<br>            res[<span class="hljs-built_in">left</span>] = num;<br>            <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span> == <span class="hljs-built_in">len</span>)<br>                <span class="hljs-built_in">len</span>++;<br>        &#125;<br>        return <span class="hljs-built_in">len</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2021/09/07/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/09/07/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># NodeJs安装</span><br><br><span class="hljs-meta"># 确认版本号</span><br>node -v<br>npm -v<br><br><span class="hljs-meta"># 安装Node.js淘宝镜像加速器（cnpm）</span><br>npm install -g cnpm --registry=https:<span class="hljs-comment">//registry.npm.taobao.org</span><br>cnpm -v<br></code></pre></td></tr></table></figure><hr><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">cnpm <span class="hljs-keyword">install</span> -g hexo-cil<br>hexo -v<br></code></pre></td></tr></table></figure><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mkdir blog<br>cd blog<br><br>sudo hexo init <span class="hljs-meta">#初始化生成博客</span><br><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta"># 启动本地博客服务 4000端口</span><br><br>hexo <span class="hljs-keyword">new</span>  <span class="hljs-string">&quot;post名称&quot;</span>  <span class="hljs-meta"># 创建新文章</span><br><br>hexo clean  <span class="hljs-meta"># 清理</span><br><br>hexo g <span class="hljs-meta"># 生成</span><br></code></pre></td></tr></table></figure><h2 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#项目根目录下安装git 部署插件</span><br><br>cnpm <span class="hljs-keyword">install </span>--save hexo-deployer-git<br><br><br><br>配置文件_<span class="hljs-built_in">config</span>.yml设置<br><br></code></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codesheep.cn/">www.codesheep.cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/07/hello-world/"/>
    <url>/2021/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
